// server.js
require("dotenv").config();
const express = require("express");
const cors = require("cors");
const { ethers } = require("ethers");

// Import the ABI from the artifacts generated by Hardhat
const gameArtifact = require("./artifacts/contracts/GameOfDeath.sol/GameOfDeath.json");

const app = express();
app.use(cors());
app.use(express.json());

// Timer settings (in seconds)
const ACTIVE_PERIOD = 20;
const INACTIVE_PERIOD = 5;
const CYCLE_DURATION = ACTIVE_PERIOD + INACTIVE_PERIOD; // 25 seconds

// Set up ethers provider to connect to local Hardhat node
const provider = new ethers.JsonRpcProvider("http://127.0.0.1:8545");

// Create wallet using the owner's private key from .env
const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);

// Use the contract address from .env and ABI from artifact
const contractAddress = process.env.REACT_APP_CONTRACT_ADDRESS;
const contractABI = gameArtifact.abi;

const gameOfDeath = new ethers.Contract(contractAddress, contractABI, wallet);

// Endpoint: GET /timer returns current phase and time left (managed by backend)
app.get("/timer", async (req, res) => {
  try {
    // Use local state machine for phases (see below)
    // For a phase-based approach, we'll maintain local variables:
    // We'll store our phase in memory.
    // (For a fresh start, you can set phaseIndex=0 and timeLeftInPhase=ACTIVE_PERIOD)
    // For simplicity, we'll use a global state defined below.
    res.json({ active: currentPhase.activeState, timeLeft: currentPhase.timeLeft, phase: currentPhase.name });
  } catch (err) {
    console.error("Error in /timer endpoint:", err);
    res.status(500).json({ error: err.message });
  }
});

// Endpoint: GET /get-score returns the on-chain score for a given address.
app.get("/get-score", async (req, res) => {
  const { address } = req.query;
  if (!address) {
    return res.status(400).json({ error: "Missing address parameter" });
  }
  try {
    const score = await gameOfDeath.getScore(address);
    res.json({ score: score.toString() });
  } catch (err) {
    console.error("Error fetching score:", err);
    res.status(500).json({ error: err.message });
  }
});

// --- Phase-based timer management ---
// We define two phases: active (20 sec) and inactive (5 sec)
const PHASES = [
  { name: "active", duration: 20, activeState: true },
  { name: "inactive", duration: 5, activeState: false },
];
let phaseIndex = 0;
let currentPhase = { ...PHASES[phaseIndex] };

// Start a local timer that ticks every second.
setInterval(() => {
  currentPhase.timeLeft = (currentPhase.timeLeft || PHASES[phaseIndex].duration) - 1;
  if (currentPhase.timeLeft <= 0) {
    // Switch to next phase
    phaseIndex = (phaseIndex + 1) % PHASES.length;
    currentPhase = { ...PHASES[phaseIndex], timeLeft: PHASES[phaseIndex].duration };

    // Update contract state to reflect new phase
    gameOfDeath.setActiveState(currentPhase.activeState)
      .then((tx) => tx.wait())
      .then(() => console.log(`Contract active state updated to ${currentPhase.activeState} on phase switch.`))
      .catch((err) => console.error("Error updating active state:", err));
  }
  // Optionally log the current phase:
  // console.log(`Phase: ${currentPhase.name}, time left: ${currentPhase.timeLeft}`);
}, 1000);

// Start the backend server on the port from .env (or default to 3000)
const PORT = process.env.PORT || 3000;
const server = app.listen(PORT, () => {
  console.log(`Backend server listening on http://localhost:${PORT}`);
});

server.on("error", (err) => {
  if (err.code === "EADDRINUSE") {
    console.error(`Port ${PORT} is already in use. Please free the port or choose another one.`);
  } else {
    console.error("Server error:", err);
  }
});
